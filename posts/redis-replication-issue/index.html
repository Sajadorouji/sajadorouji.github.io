<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="en"><meta name=color-scheme content="light dark"><meta http-equiv=content-security-policy content="upgrade-insecure-requests; block-all-mixed-content; default-src 'self'; child-src 'self'; font-src 'self' https://fonts.gstatic.com https://cdn.jsdelivr.net/; form-action 'self'; frame-src 'self'; img-src 'self'; object-src 'none'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com/ https://cdn.jsdelivr.net/; script-src 'self' 'unsafe-inline' https://www.google-analytics.com; prefetch-src 'self'; connect-src 'self' https://www.google-analytics.com;"><meta name=author content="Sajad Orouji"><meta name=description content="Redis Replication Issues"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis Replication Issues"><meta name=twitter:description content="Redis Replication Issues"><meta property="og:title" content="Redis Replication Issues"><meta property="og:description" content="Redis Replication Issues"><meta property="og:type" content="article"><meta property="og:url" content="https://sajadorouji.com/posts/redis-replication-issue/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-07-05T00:00:00+00:00"><meta property="article:modified_time" content="2018-07-05T00:00:00+00:00"><title>Redis Replication Issues · Sajad Orouji</title><link rel=canonical href=https://sajadorouji.com/posts/redis-replication-issue/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.93c41bf1e522f85ecda7355985f09000f71fc1d64dda9f74051b0fa06210e93f.css integrity="sha256-k8Qb8eUi+F7NpzVZhfCQAPcfwdZN2p90BRsPoGIQ6T8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.f37febc669ce189201c1918fac1948a254686c8d366a312c2d72b2bb71ad97d1.css integrity="sha256-83/rxmnOGJIBwZGPrBlIolRobI02ajEsLXKyu3Gtl9E=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><meta name=generator content="Hugo 0.84.1"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>Sajad Orouji</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About Me</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://sajadorouji.com/posts/redis-replication-issue/>Redis Replication Issues</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i>
<time datetime=2018-07-05T00:00:00Z>July 5, 2018</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>
6-minute read</span></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/redis/>redis</a></span>
<span class=separator>•</span>
<span class=tag><a href=/tags/replication/>replication</a></span></div></div></header><div><h2 id=redis-replication-issue>Redis Replication Issue
<a class=heading-link href=#redis-replication-issue><i class="fa fa-link" aria-hidden=true></i></a></h2><p>Redis master-slave replication is one way to make our data more Robust and available, but everything has its own issue.
In this document, we walk-through every replication problem and find a proper solution by addressing related configuration.</p><h3 id=truth-or-dare->Truth or Dare ?!
<a class=heading-link href=#truth-or-dare-><i class="fa fa-link" aria-hidden=true></i></a></h3><p>Bad beginning :D, what if you set up your Redis server on the virtual environment with a low-speed SAN-storage and fiber-optic network, I mean 10GB network bandwidth and 7200RPM hard drive.
In that case, you have dared to do this so I’ll tell you the truth you will suffer multiple master-slave disconnections during every BGSAVE,High Slave request or high request to master !!!
so what is the solution for this:
OK, here’s you and Diskless Replication !!!</p><p>Here is some definition about Redis diskless-replication:
The Redis master creates a new process that directly writes the RDB file to slave sockets, without touching the disk at all.
With disk-backed replication, while the RDB file is generated, more slaves can be queued and served with the RDB file as soon as the current child producing the RDB file finishes its work. With diskless replication instead once the transfer starts, new slaves arriving will be queued and a new transfer will start when the current one terminates.</p><p>When diskless replication is used, the master waits a configurable amount of time (in seconds) before starting the transfer in the hope that multiple slaves will arrive and the transfer can be parallelized.</p><p>With slow disks and fast (large bandwidth) networks, diskless replication works better.</p><p><code>repl-diskless-sync no</code></p><p>When diskless replication is enabled, it is possible to configure the delay the server waits in order to spawn the child that transfers the RDB via socket to the slaves.</p><p>This is important since once the transfer starts, it is not possible to serve new slaves arriving, that will be queued for the next RDB transfer, so the server waits for a delay in order to let more slaves arrive.</p><p>The delay is specified in seconds, and by default is 5 seconds. To disable it entirely just set it to 0 seconds and the transfer will start ASAP.</p><p><code>Repl-diskless-sync-delay 5</code></p><p>Ok, the last section we see diskless replication but here is a problem, this feature is EXPERIMENTAL CURRENTLY so if you are using Redis in your production it’s not a good idea to bring it on(For now).
So we must tune Redis server without this awesome feature, that brings us here.</p><h3 id=rules-meant-to-broke-and-default-values-meant-to-change>Rules meant to broke and Default values meant to change!
<a class=heading-link href=#rules-meant-to-broke-and-default-values-meant-to-change><i class="fa fa-link" aria-hidden=true></i></a></h3><p>When you install Redis and start it, you are using a default setting such as SNAPSHOTTING, LOGGING or REPLICATION.
Everything while be happy ever after till you face with a loaded gun !!!
Yep, when using Redis with the default configuration in a production environment it’s like a loaded gun.
Most of these options must change and depends on your environment, so we walk-through some of this option that related to replication!!!</p><p><code>repl-ping-slave-period 10</code></p><p>Slaves send PINGs to the server in a predefined interval. It&rsquo;s possible to change this interval with the repl_ping_slave_period option. The default value is 10 seconds.
Make sure you have set this item properly that may cause of broken master-slave connection in a high tense environment
If a master is weak on the process unit or slow hard drive is used set this value a little higher could be a good decision.</p><p><code>repl-timeout 60</code></p><p>Timeout, what ??? Yes, everything has a beginning and an end, do you remember it?
So slave ping master in defined interval’s and master replied it with ACK, so what if slave won&rsquo;t send ping or master did not send ACK ??
This means the connection is broken but maybe it’s some short network issue that takes 2 minute long. What do we have to do?
Simply replication timeout default value is set to 60 seconds, this means when the slave or master cant reply to each other in 1 minute, the connection is broke.
It is important to make sure that this value is greater than the value specified for repl-ping-slave-period otherwise a timeout will be detected every time there is low traffic between the master and the slave.
This option has direct interaction with backlog and ping interval
When in a specific interval slave ping master and check master availability if the master were in bad shape and have lots of requests that can&rsquo;t handle ping-ack, putting up this timeout might be a good idea.
Another reason to see why this option is relevant to backlog is when timeout reached and still master server unable send ACK to slave, which become broken connection and partial sync data will be stored from the last synchronisation, if master/slave be able to reply replication ping before backlog being full then partial sync will be run, in any condition that disconnection take longer then that backlog size be overload full sync will require
look at this picture, ring any bells?</p><p>redis-master :</p><p><img src=/images/redis-master.jpg alt="Redis Master"></p><p>redis-slave:</p><p><img src=/images/redis-slave.jpg alt="Redis Slave"></p><p>The following option sets the replication timeout for:</p><ol><li>Bulk transfer I/O during SYNC, from the point of view of a slave.</li><li>Master timeout from the point of view of slaves (data, pings).</li><li>Slave timeout from the point of view of masters (REPLCONF ACK pings).</li></ol><p><code>repl-backlog-size 1mb</code></p><p><img src=/images/repl-backlog.jpg alt="Redis Default Backlog"></p><p>Set the replication backlog size. The backlog is a buffer that accumulates slave data when slaves are disconnected for some time, so that when a slave wants to reconnect again, often a full resync is not needed, but a partial resync is enough, just passing the portion of data the slave missed while disconnected.</p><p>The bigger the replication backlog, the longer the time the slave can be disconnected and later be able to perform a partial re-synchronization.
The backlog is only allocated once there is at least a slave connected.
After a master has no longer connected slaves for some time, the backlog
Replication backlog for Redis server that serves to many connections or has greater then 2GB data on slow disk and the weak server is necessary.
When flow of query hit server, main thread may become unable to ping or ACK-PING the master/slave so connection will be broken and on next attempt slave request a partial sync and if amount of changes applied to master become greater then default backlog value which is 1mb will be considered as lack of backlog situation and going for full sync</p><p>backlog only create when at least 1 slave be connected, and backlog become available
so when slave become unavailable master keep backlog for a period of time which by default is 1 hour.
So its a good idea for prevention of wasting resources set the backlog-TTL to lower number that when slave become unavailable to long back-log will be freed.</p><p><code>repl-backlog-ttl 3600</code></p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2015 -
2021
Sajad Orouji</section></footer></main><script src=/js/coder.min.235666b114443867d43eeb5799d51f6252965e5163f338285e113fa381d3d27e.js integrity="sha256-I1ZmsRREOGfUPutXmdUfYlKWXlFj8zgoXhE/o4HT0n4="></script></body></html>